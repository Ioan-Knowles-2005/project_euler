# Cyclical Figurate Numbers
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
# and are generated by the following formulae:
# Triangle = n(n+1)/2
# Square = n^2
# Pentagonal = n(3n-1)/2 
# Hexagonal = n(2n-1)
# Heptagonal = n(5n-3)/2
# Octagonal = n(3n-2)
# The ordered set of 8128, 2882, 8281 has three interesting properties: 
# 1) It is cyclic (last two = first two of next number)
# 2) 8128 = Triangle, 2882 = Square, 8281 = Pentagonal
# 3) This is the only set of 4-digit numbers with this property

#Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
#triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

from itertools import permutations

def triangle_list():
    triangular_numbers = []
    for n in range(45, 141):
        triangular_numbers.append(int(n*(n+1)/2))
    return triangular_numbers

def square_list():
    square_numbers = []
    for n in range(32, 100):
        square_numbers.append(int(n**2))
    return square_numbers

def pentagonal_list():
    pentagonal_numbers = []
    for n in range(26, 82):
        pentagonal_numbers.append(int(n*(3*n-1)/2))
    return pentagonal_numbers

def hexagonal_list():
    hexagonal_numbers = []
    for n in range(23, 71):
        hexagonal_numbers.append(int(n*(2*n-1)))
    return hexagonal_numbers

def heptagonal_list():
    heptagonal_numbers = []
    for n in range(21, 64):
        heptagonal_numbers.append(int(n*(5*n-3)/2))
    return heptagonal_numbers

def octagonal_list():
    octagonal_numbers = []
    for n in range(19, 59):
        octagonal_numbers.append(int(n*(3*n-2)))
    return octagonal_numbers

def build_polygonal_dict():
    polygonal_numbers = {
        3: triangle_list(),
        4: square_list(),
        5: pentagonal_list(),
        6: hexagonal_list(),
        7: heptagonal_list(),
        8: octagonal_list()
    }
    return polygonal_numbers


def build_prefix_dict(polygonal_numbers):
    """Build a dictionary grouping numbers by their first two digits."""
    prefix_dict = {i: {} for i in range(3, 9)}
    for poly_type, numbers in polygonal_numbers.items():
        for num in numbers:
            prefix = str(num)[:2]
            if prefix not in prefix_dict[poly_type]:
                prefix_dict[poly_type][prefix] = []
            prefix_dict[poly_type][prefix].append(num)
    return prefix_dict

def find_cyclic_set():
    polygonal_numbers = build_polygonal_dict()
    prefix_dict = build_prefix_dict(polygonal_numbers)
    polygonal_types = list(polygonal_numbers.keys())

    def is_cyclic_sequence(sequence):
        return all(str(sequence[i])[-2:] == str(sequence[i + 1])[:2] for i in range(len(sequence) - 1)) and \
               str(sequence[-1])[-2:] == str(sequence[0])[:2]

    def backtrack(path, remaining_types):
        if not remaining_types:
            if is_cyclic_sequence(path):
                return path
            return None

        last_two_digits = str(path[-1])[-2:]
        for poly_type in remaining_types:
            if last_two_digits in prefix_dict[poly_type]:
                for next_num in prefix_dict[poly_type][last_two_digits]:
                    new_path = path + [next_num]
                    new_remaining = remaining_types - {poly_type}
                    result = backtrack(new_path, new_remaining)
                    if result:
                        return result
        return None

    # Try starting from each polygonal type
    for poly_type in polygonal_types:
        for num in polygonal_numbers[poly_type]:
            result = backtrack([num], set(polygonal_types) - {poly_type})
            if result:
                return result

    return None

cyclic_set = find_cyclic_set()
sum_of_cyclic_set = sum(cyclic_set)
print(f"The cyclic set is {cyclic_set} and its sum is {sum_of_cyclic_set}")